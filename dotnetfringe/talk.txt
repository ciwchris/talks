Hi, I'm Chris Lopes. Welcome to my talk on my experience using clojure, elixir and. Net core.

Problem [image: come in we're closed]
I'm a web developer, but I moonlight checking kids into classrooms. We have a pretty slick system. Parents come with their drivers license, hold it up to a scanner, logs then in bringing their list of kids on a computer where they can select which kids they are checking in. A tag is printed on a sticker for each kid and a receipt for the parent. In the system the max number of kids for each classroom can be set. Unfortunately the system is happy to continue to check in kids after the limit has been reached. Therefore one of my duties is to monitor the number of kids in each classroom and once reached update a whiteboard to mark the class full. Unfortunately I can't monitor the numbers from another device, like my phone, so every so often I have to interrupt families checking in, go to the admin on the computer, check the numbers, hope the classroom limit hasn't already been exceeded (which makes the teachers none to happy [screenshot: no no no]) and then let families continue to check-in. One day I had enough, this is a problem I should be able to do something about. I checked if they have an API. They do! And they have a web hook too!

The plan [image: side by side apps]
This is the application I built. There are two screens. The first shows the status of all classrooms, identified by color, and will be displayed next to the check in screen screen. The second displays the count of each class room and has buttons to increment and decrement the count, if, for example, and kid is moved from one class to another. Both screens establish an web socket connection to the server. When the check in system sends a web hook event the server will retrieve send requests to the API and updates its internal list of check ins and broadcasts the new list of check-ins to any connected clients.

About [image: dilbert - Microsoft all the things]
That was the vision I had. The plan was to use this as a learning project. This talk is my reflections after implementing this project using different stacks. For perspective, by day I'm a asp.net developer. I have been my whole career. I consider myself a fairly typical developer. Developing in more than a 9-5 obligation, but I'm not going home every night to work on an open source project either. I consult StackOverflow often, but rarely contribute. [image: SO]. Low score, but top 37% this quarter, yeah! I follow a select set of people on twitter, listen to a handful of podcasts, watch the occasional video. Attend the occasional conference, but have never spoken at one before. At work we, for the most part, use the Microsoft way and, surprise, surprise, Angular is our JavaScript framework of choice. [image: none of these things] But we don't have a JavaScript build process. No grunt, gulp, webpack, rollup, eslint, babel nor npm scripts. [image: nuget w/ js libs]. Instead we use NuGet to install our libs and BundleTransformer to bundle and minify.

[image: arch] What may make me atypical is at home my primary computer is Arch Linux and so doing any asp.net work at home was not friendly. Mono is an impressive project. I remember, back in the day, being jealous of Quicksilver on the Mac. I came across gnome do and learned it was written in Mono. But, nevertheless, there are development challenges. First, you can't run NuGet, so I'm not sure how packages are installed. And there's a limit on what can be done on the command line.[image: SO mono cmdline] For example, I asked this question on StackOverflow. How do you even get started? I guess I can answer my own question now. With this background I start my learning.


Clojure [image: clj with cljs|color change]

Let's talk about Clojure. Clojure is a dialect of Lisp which has the mantra of code as data. It's a dynamic language. There are several implementations, including one that runs on the CLR. The primary implementations are on the JVM (and has good interoperability with Java), and ClojureScript, which compiles to JavaScript using Google Closure Library. Cognitect is the maintainer of Clojure and Rich Hickey is its benevolent dictator for life.

user=> (+ 1 2 3 4)
10
user=> (+ 1 (* 2 3) 4)
11

If you aren't familiar with Lisps the first two things you'll notice are the parentheses and prefix notation. [code: addition(maybe klipse)].


The parens are a list. Lists are evaluated. The first position in the list is the operator. The rest are arguments to the operator. Evaluation occurs from the inside out. So in the second example 2 and 3 are multiplied and then use in the addition evaluation. These simple rules have the effect of making the code simple and consistent.

user=> (map inc (range 1 10))
(2 3 4 5 6 7 8 9 10)
user=> (filter even? (range 1 10))
(2 4 6 8)
user=> (reduce + (range 1 10))
45
user=> (reduce + (filter even? (map inc (range 1 10))))
30

Here are examples of the basic functions of map filter and reduce. In the last example you begin to see the common complaint about lisps, all the parens. It is true that you get used to them, and with a proper editor you don't need to count the parens, to make sure the parens are balanced. But it is important to structure the code to make it readable.

user=> (->>
         (range 1 10)
         (map inc)
         (filter even?)
         (reduce +))
30

Additionally Clojure has threading macros to pipe values from one expression to the next. This often times can make the code easier to read. In this example the result from the previous expression is piped as the last argument into the next expression.

[image: lein] The most prevalent to automate project related tasks. You can think of it similarly as to NPM. You can create project, using various templates. Retrieve dependencies, build the project, run tests, start a repl, plus more. Additionally you can include community plugins, or write your own.

[image: blank slide] Unlike other stacks, Clojure doesn't have a complete, end-to-end, web framework. Instead the it is common to use Ring as a base with other libraries which run on top of it, like Compojure for routing. [image: Arachne] This has been identified as an issue and recently a kickstarter campaigned was funded to build Arachne, a complete web framework.

[image: reagent logo] The other side of the story with Clojure is ClojureScript. There are several ClojureScript libraries which wrap React. Reagent is one such library. It allows the creation of React components in ClojureScript. Reagent has a lein template to generate a new Reagent project, including the server side bits, Ring and Compojure. Therefore this seems like the best way to get started with the project.

[cast: clojure creation]

When can then set up our routes. One route to handle web hook requests coming from the system, the other to return the check in information to clients.

(defroutes site-routes
  (GET "/" [] (render-file "templates/index.html" env))
  (GET "/checkins" [] {:status 200
                       :body (api/create-list-of-checkin-count-by-group env)})
  (POST "/newcheckin" request {:status 200
                               :body (api/register-checkin request env)})
  (resources "/")
  (not-found "Not Found"))

To retrieve new checkins we define an overloaded version of the function. If no arguments are supplied recursion is used to call the function again with the initial set of arguments. A new request to the system API is created and sent and the results stored in a map. Only 20 check-in entries are returned at a time, so while we have entries which currently do not exist in our map we will send another request to the system API with a new page number. Once we have all check-ins the map is returned.
(defn- retrieve-checkins
  "Page through the list of checkins from thecity and add them to a vector which
  we be stored in an application cache, then return it for use"
  ([] (retrieve-checkins 1 @checkins-store))
  ([page-number checkins]
   (let [today (.toString (time/today) "MM/dd/yyyy")
         new-checkins (retrieve-checkins-for-result-page page-number)
         new-checkin-store (add-new-checkins-to-checkins-store checkins new-checkins today)]
     (if (not= (count new-checkin-store) (count checkins))
       (retrieve-checkins (inc page-number) new-checkin-store)
       (do
         (swap! checkins-store into checkins)
         @checkins-store)))))

The API requires a key and token. To keep these secret they are stored in an edn file, and will not be included in the repo. Edn files contain clojure data, and so can be loaded and used by the application.

(defn- load-config
  "Load thecity API config"
  []
  (edn/read-string (slurp "src/clj/kids_checkin/config.edn")))

The API uses HMAC for authentication. Clojure does have library to produce HMAC signatures. But it is trivial to use Java interrupt to generate the required signature.

(defn- create-secret-key [key mac]
  (SecretKeySpec. (.getBytes key) (.getAlgorithm mac)))

(defn- sign-text-with-key
  "Returns the signature of a string with a given key, using a SHA-256 HMAC."
  [key string]
  (let [mac (Mac/getInstance "HMACSHA256")
        secretKey (create-secret-key key mac)]
    (-> (doto mac
          (.init secretKey)
          (.update (.getBytes string)))
        .doFinal)))

When there is a request to retrieve check-ins a list is created for each classroom and calculates the count for each.

(defn- count-checkins-for-group
  "Count the number of checkins in each checkin group"
  [group-id checkins]
  (count (filter #(= group-id (second %)) checkins)))

(defn create-group-count
  [checkins]
  [{:color "red" :count (count-checkins-for-group 108117 checkins)…}
   {:color "orange" :count (count-checkins-for-group 108119 checkins)…}
   {:color "yellow" :count (count-checkins-for-group 108120 checkins)…}
   {:color "green" :count (count-checkins-for-group 144673 checkins)…}
   {:color "blue" :count (count-checkins-for-group 108123 checkins)…}
   {:color "purple" :count (count-checkins-for-group 89515 checkins)…}])

Using ClojureScript, on the client, we initialize the page.

(defn mount-root []
  (reagent/render [checkin-page] (.getElementById js/document "app")))

(defn save-checkins [response]
  (swap! checkins (fn [] response)))

(defn get-checkins []
    (GET "/checkins" {:handler save-checkins}))

Then we setup the page components. We create a container, at the bottom, and pass in the list of check-ins to, top, which iterates through the list creating a container for each classroom. In this version of the app the classroom name is outputted along with the current count of the classroom and the max number for the classroom.

(defn list-classes [checkins]
  [:div
   [:ul
    (for [class checkins]
      ^{:key (:id class)} [:li
                           [:div {:style {:background-color (:color class)}}
                            (str (:name class) " " (:count class) "/" (:max class))]])]])

(defn checkin-page []
  [:div
   [list-classes @checkins]])

Deployment:
[image: heroku] Reagent includes a Procfile to deploy to Heroku. They provide simple instructions on deploying a reagent application. Information, such as how to supply configuration information, namely the API key and token, is not discussed.

Lessons:
[image: blank green again] That covers most of the core pieces.
- The community is friendly, enthusiastic and active (lots of libraries to pick from)
- Repl driven development can handy (instead of debugging and inspecting)
- ClojureScript is fun and refreshing
- Figwheel makes things simple (hooks up browser repl, shows simple errors)
;; working in clojurescript
(def incremented-counts
  (map #(assoc % :count 2) @checkins))
(swap! checkins (fn [] incremented-counts))
    [image: heads up display]

- What editor to use? (emacs/spacemacs, but cursive has come a long ways)
- No comprehensive framework to guide the way (what tools to use? How to use them? I stuck with what reagent gave me, but when having to expand from there it was difficult to figure out the best thing to use.
- Tougher to come back to (How did that work. How did I use the tool to do X. I imagine this is not an issue when experienced level is achieved.)
- [image: SO error]When things go bad they can be challenging to figure out (Errors can be lengthy and misleading. Community tries to be helpful by cataloging exceptions and how to read them. Constant high item on the state of clojure survey. Things are improving. Clojure.spec is a good step forward.)
- [image/code: keep fn ex]Clojure can be terse and hard to read (why use single letter names)


Elixir [image: elixir logo|color change]

Let's talk about Elixir. Elixir is also a dynamic language. It is built on, and extends Erlang, and therefore runs on the Erlang virtual machine, aka BEAM. It has great support for distributed systems, being able to scale horizontally. It achieves this by running all code in processes which send messages to each other. These are not OS processes or threads. These are extremely lightweight. Tens of thousands can be running simultaneously. Jose Valim, of Plataformatec, is the creator of Elixir.


iex(1)> a = "hello"
"hello"
iex(2)> "hello" = a
"hello"
iex(3)> "world" = a
** (MatchError) no match of right hand side value: "hello"

An important concept in Elixir is pattern matching. In this example it appears the equal is assignment, but it's actually a match operator.

iex(1)> {a, b} = {"hello", "world"}
{"hello", "world"}
iex(2)> {a, "world"} = {"hello", "world"}
{"hello", "world"}
iex(3)> {a, "world!"} = {"hello", "world"}
** (MatchError) no match of right hand side value: {"hello", "world"}
iex(3)> case {:ok, "hello world"} do
...(3)>      {:ok, result} -> IO.puts result
...(3)>      {:error, result} -> IO.puts result
...(3)>      _ -> IO.puts "something unexpected"
...(3)> end
hello world
:ok

Tuples are used often in Elixir to send data to a function as a single argument or return multiple pieces of data from a function. Patterning matching is used with destructing to extract and branch on the results. Because of this if statements appear less frequently in Elixir.

iex(1)> Enum.map(1..10, fn x -> x + 1 end)
[2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
iex(2)> Enum.filter(1..10, fn x -> 0 == rem(x, 2) end)
[2, 4, 6, 8, 10]
iex(3)> Enum.reduce(1..10, fn(x, acc) -> acc + x end)
55
iex(4)> 1..10 \                                  
...(4)>     |> Enum.map(fn x -> x + 1 end) \
...(4)>     |> Enum.filter(fn x -> 0 == rem(x, 2) end) \
...(4)>     |> Enum.sum
30


For comparison, here are the basic map, filter and reduce (not the must terse version). The last example shows the use of the piper operator, inspired by f#.

iex(1)> {:ok, agent} = Agent.start_link fn -> [] end
{:ok, #PID<0.86.0>}
iex(2)> Agent.update(agent, fn list -> ["hello world" | list] end)
:ok
iex(3)> Agent.get(agent, fn list -> list end)
["hello world"]
iex(4)> Agent.stop(agent)
:ok

Processes are used to store state. Elixir uses OTP (Open Telecom Protocol), a set of libraries for working with processes. In this example we use the Agent abstraction to store state. First a process is started with an empty list. The list is updated by prepending a new item to the list. Then the list is retrieved. Finally the process is stopped.


.Net [image: dotnet foundation logo|color change]

I'll skip the intro to .net and c# and go directly into installation. [image: install options]. Or not. Well, the arch community is active, maybe somebody created a package for. [image: aur]. This looks promising. [code: dotnet not found] Oh, I guess it only runs .net core applications. [image: install options]. Well, I could try using it with Docker, but with my very limited experience I don't know a good development flow, and history has taught me I should limit the number of things I learn at the same time, so I guess an Ubuntu VM it is.

End [^d]
Thank you for attending my talk. If you would like to discuss these topics further, have questions, ideas or pass knowledge on to me I'll be around. Come find me. Thanks!

